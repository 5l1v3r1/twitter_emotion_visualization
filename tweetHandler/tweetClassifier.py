"""
Classifier Class

This class uses Maximum entropy model to perform classification. 
In order to train the classifier requires Mega Model Optimization Package installed on the system.
This package can be downloaded from http://www.umiacs.umd.edu/~hal/megam/
"""
import os
import math

class tweetClassifier:
	"""
	tweetClassifier Class
	"""
	
	def __init__(self, emotionDict):
		"""
		Initializes the tweetClassifier class. Parameters:
			1. emotionDict:Dictionary that maps emotion to a number and vice versa. The numbers should be consecutive starting from 1.
		"""
		self.emotionDict = emotionDict.copy()
	
	def train(self, trainCorpusFile, outputFile, megamPath = ""):
		"""
		This functions invokes the MEGA M optimization package to train on the corpus. Parameters:
			1. trainCorpusFile: This file contains features of the tweet corpus as extracted by corpusExtract method of the tweetFeatureExtractor class.
			2. outputFile: The final weight vector used in the maximum entropy model are saved in this file.
			3. megamPath: It is the path to the directory where the megam package binary is stored.
			
		"""
		if (megamPath == "" and os.getenv('MEGAMPATH') == None):
			print "megam path not set"
			return 0
		if(megamPath == ""):
			megamPath = os.getenv('MEGAMPATH')
		
		cmd = "%s/megam -fvals multiclass %s > %s" %(megamPath, trainCorpusFile, outputFile)
		print cmd
		s = os.system(cmd)	
		
	
	def load(self, weightFile):
		"""
		Loads the weight vectors from the file outputed after training. Parameters:
			1.weightFile: Output of train function
		
		This function should be called before any classification function is called.
		"""
		f = open(weightFile)
		self.featureDict = {}
		
		line = f.readline()
		while line:
			fields = line.strip().split()
			feature = fields[0].strip()
			weights = [float(x) for x in fields[1:]]
			self.featureDict[feature] = [0]*len(weights)
			for i in range(len(weights)):
				self.featureDict[feature][i] = weights[i]
			line = f.readline()
			
		f.close()
		
	
	def tweetClassify(self, feature_dict, threshold = 0.5):
		"""
		Classifies a tweet. Parameters:
			1. feature_dict: Dictionary of features for the tweet as extracted by tweetFeatureExtractor class
			2. threshold (optional): The threshold specifies the threshold probability for the tweet to be classified.
			eg: If max probability of any class given this tweet feature is greater than the threshold the classifier goes ahead with classificaton else classifies the tweet as neutral, containing no emotion. Threshold can control the precision and recall.
			
		return: Emotion in the tweet.
		rtype: Tuple (id, emotion) id is the emotion id as in emotionDict, and emotion is string.
		"""
		scores = [0]*8
		for i in range(8):
			s = self.featureDict['**BIAS**'][i]
			for (feature, value) in feature_dict.items():
				s += self.featureDict.get(feature, [0.0]*8)[i]*value
			scores[i] = s
		scores1 = [math.exp(x) for x in scores]
		s = sum(scores1)
		scores = [x/s for x in scores1]
		m = max(scores)
		if (m >= threshold):
			emotionI = scores.index(m)
			emotion = self.emotionDict[emotionI]
		else:
			emotionI = 0
			emotion = "neutral"
		return (emotionI, emotion)
	
	def corpusClassify(self, testFile):
		"""
		Classifies all the tweets in the testfile. The test file has the same format as generated by the tweetFeatureExtractor class.
			1. testFile: File name of the test file. Format of file: "true_emotion_id feature_1 value_1 ... feature_n value_n"
		
		Outputs Statistics about the test. Recall, precision and Fmeasure are printed.
		
		return: Dictionary where key is the emotion_id and value is a list of 3 containing the following precision, recall and Fmeasure.
		rtype: dict
		"""
		f = open(testFile)
		tweets = f.readlines()
		f.close()
		count = len(tweets)
		correct = 0
		emotionMatrix={}
		for i in range(8):
			emotionMatrix[i] = [0]*3

		for tweet in tweets:
			fields = tweet.strip().split()
			emotion = int(fields[0].strip())
			features_list = fields[1:]
			features_dict = {}
			for i in range(0, len(features_list), 2):
				feature = features_list[i].strip()
				value = float(features_list[i+1].strip())
				features_dict[feature] = value
			
			emotionMatrix[emotion][2] += 1
			(pEmotion, pEmotionName) = self.tweetClassify(features_dict)
			emotionMatrix[pEmotion][1] += 1
			if pEmotion == emotion:
				correct+=1
				emotionMatrix[emotion][0] += 1
		stats = {}
		print "Emotion\t\tPrecision\tRecall\tF-measure"
		for i in range(1, 8):
			emotionN = self.emotionDict[i]
			stats[emotionN] = [0]*3
			p = float(emotionMatrix[i][0]+1)/float(emotionMatrix[i][1]+1)
			r = float(emotionMatrix[i][0]+1)/float(emotionMatrix[i][2]+1)
			f = 2*p*r/(p+r)
			stats[emotionN][0]  = p
			stats[emotionN][1]  = r
			stats[emotionN][2]  = f
			print "%s\t\t%.2f\t\t%.2f\t\t%.2f" %(emotionN, p, r, f)
		return stats
